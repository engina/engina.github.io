<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Cross-domain data-push methods compared</title>
        <meta name="viewport" content="width=device-width">
        <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" type="text/javascript"></script>
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Cross-domain data-push methods compared</h2>
<p class="meta">31 Mar 2010</p>

<div class="post">
<p style="text-align: left;">I've been playing with cross-domain (<strong>XD</strong>) data-pushing techniques lately and now I'll try to compare each available technique. These techniques allows server to push messages to the client. A brief summary of comparison is available in the table below, following the table you can find more detailed explanation for each technique.</p>
<table id="eng_xd_tbl" style="width: 100%; text-align: center; cursor: default; border: 1px solid black;">
<tbody>
<tr>
<td class="style7" style="background-color: #000066; text-align: center; color: white;">Technology</td>
<td style="background-color: #000066; color: #ffffff; text-align: center;" colspan="2">Reading Data</td>
<td class="style1" style="background-color: #000066; color: #ffffff; text-align: center;" colspan="2" bgcolor="DarkBlue">Writing Data (HTTP GET)</td>
<td style="background-color: #000066; color: #ffffff; text-align: center;" colspan="2">Writing Data (HTTP POST)</td>
<td style="background-color: #000066; color: #ffffff; text-align: center;">Advantages</td>
<td style="background-color: #000066; color: #ffffff; text-align: center;">Disadvantages</td>
<td style="background-color: #000066; color: #ffffff; text-align: center;">Conclusion</td>
</tr>
<tr>
<td class="style7" style="font-weight: bolder; text-align: left;">XHR</td>
<td class="style5" style="background-color: red; text-align: center;" colspan="2">No</td>
<td class="style4" style="background-color: orange; text-align: center;" colspan="2">Yes</td>
<td class="style4" style="background-color: red; text-align: center;" colspan="2">No</td>
<td class="style12">XHR is good at error handling</td>
<td class="style4">
<ul>
<li><span style="line-height: normal;">Only very recent browsers implementing access-control specs allow requests to be made.</span></li>
<li><span style="line-height: normal;">Cannot read responses at all</span></li>
<li><span style="line-height: normal;">Data writing is limited to 2kb</span></li>
</ul>
</td>
<td style="background-color: red; text-align: center;">
<h2>FAIL</h2>
<p>Because: a cross browser method with XHR for XD communication does NOT exist.</td>
</tr>
<tr>
<td class="style8" style="font-weight: bolder; text-align: left;">Script</td>
<td class="style9" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style6" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style6" style="background-color: red; text-align: center;" colspan="2">No</td>
<td class="style13">
<ul>
<li><span style="line-height: normal;">Can read the responses</span></li>
<li><span style="line-height: normal;">Easy to implement</span></li>
</ul>
</td>
<td class="style6">
<ul>
<li><span style="line-height: normal;">Hard to detect connection problems</span></li>
<li><span style="line-height: normal;">Data writing is limited to 2kb</span></li>
<li><span style="line-height: normal;">Long-polling is required.</span></li>
<li><span style="line-height: normal;">If remote site is not trusted, can run arbitrary code on your site.</span></li>
</ul>
</td>
<td style="background-color: #90ee90;">
<h2 style="text-align: center;">Works</h2>
</td>
</tr>
<tr>
<td class="style7" style="font-weight: bolder; text-align: left;">IFRAME + hack</td>
<td class="style9" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style4" style="background-color: red; text-align: center;" colspan="2">No</td>
<td class="style11">
<ul>
<li><span style="line-height: normal;">Can read responses</span></li>
<li><span style="line-height: normal;">Remote sites response can be filtered by your proxy program (i.e. php) on the origin, hence a not trusted remote site can be used.</span></li>
</ul>
</td>
<td>
<ul>
<li><span style="line-height: normal;">A relaying/proxying dynamic program (i.e. php) is necessary on the domain the request is originating from.</span></li>
<li><span style="line-height: normal;">Long polling is required.</span></li>
</ul>
</td>
<td style="background-color: #90ee90;">
<h2 style="text-align: center;">Works</h2>
</td>
</tr>
<tr>
<td class="style7" style="font-weight: bolder; text-align: left;">IFRAME + form</td>
<td class="style9" style="background-color: red; text-align: center;" colspan="2">No</td>
<td style="background-color: orange; text-align: center;" colspan="2">Yes</td>
<td style="background-color: orange; text-align: center;" colspan="2">Yes</td>
<td class="style11">Can send large data</td>
<td>
<ul>
<li><span style="line-height: normal;">Cannot read responses</span></li>
<li><span style="line-height: normal;">"Start navigation" (aka click) sound of IE when you do form.submit() is really a sad deal breaker.</span></li>
</ul>
</td>
<td style="background-color: red; text-align: center;">
<h2>FAIL</h2>
<p>Because: see Disadvantages</td>
</tr>
<tr>
<td class="style3" style="font-weight: bolder; text-align: left;">IFRAME + form + hack</td>
<td class="style9" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style4" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style12">
<ul>
<li><span style="line-height: normal;">Can send large data</span></li>
</ul>
</td>
<td>"Start navigation" (aka click) sound of IE when you do form.submit()<br />
<strong>(NOTE: This really is a deal breaker, funny fun though)</strong></td>
<td style="background-color: red; text-align: center;">
<h2>FAIL</h2>
<p>Because: see Disadvantages</td>
</tr>
<tr>
<td class="style3" style="font-weight: bolder; text-align: left;">Flash</td>
<td class="style10" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style4" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style4" style="background-color: #90ee90; text-align: center;" colspan="2">Yes</td>
<td class="style12">
<ul>
<li><span style="line-height: normal;">A true persistent TCP connection ready to be used.</span></li>
<li><span style="line-height: normal;">Good error handling</span></li>
<li><span style="line-height: normal;">Can deal with binary protocols, hence can save bandwidth around 90%</span></li>
</ul>
</td>
<td class="style4">Note that I've tried very very hard to find disadvantages of this method.</p>
<ul>
<li><span style="line-height: normal;">Plug-in availability debate.</span></li>
<li><span style="line-height: normal;">Not available in mobile platforms </span></li>
<li>Slim chance of network problems</li>
</ul>
</td>
<td style="background-color: #90ee90; text-align: center;">
<h2>Works</h2>
</td>
</tr>
<tr>
<td colspan="10"><span style="background-color: #90ee90;">Yes</span>: Able to send request and read the response. i.e. Being able to send a request to http://foo.com/write.php?data=bar, which writes data "bar", and in return being able to read the response (such as "Write Successful" or "Write Fail"<br />
<span style="background-color: orange;">Yes</span>: Able to send request but cannot read the response<br />
<span style="background-color: red;">No</span>: Cannot send request nor response.</td>
</tr>
</tbody>
</table>
<h2>Introduction</h2>
<p>I've studied cross domain communication as it is two separate tasks; one is <strong>reading</strong> other one is <strong>writing.</strong></p>
<h2>Available Methods</h2>
<h3>1. XHR</h3>
<p>XHR is the way to go with same-origin requests (i.e. non-XD), unfortunately it does not with with XD requests. So far browsers would simply throw an exception when you tried to do a XD request via XHR, which is defined by the standard.</p>
<blockquote><p>If the <a href="http://www.w3.org/TR/XMLHttpRequest/#origin">origin</a> of <var>url</var> is not <a href="http://www.w3.org/TR/XMLHttpRequest/#same-origin">same origin</a> with the <a href="http://www.w3.org/TR/XMLHttpRequest/#xmlhttprequest-origin"><code>XMLHttpRequest</code> origin</a> the user agent should raise a <code><a href="http://www.w3.org/TR/XMLHttpRequest/#security-err">SECURITY_ERR</a></code> exception and terminate these steps.</p></blockquote>
<p>A new standard is worked out called <a title="Access Control" href="http://www.w3.org/TR/access-control/#requirements">access-control</a> which now enables you to do XD XHR requests. Essentially it is what Flash's policy file is to the XHR. XHR is only allowed when the target domain explicitly allows your domain.</p>
<blockquote>
<ol>
<li>Should not allow loading and exposing of resources from 3rd party servers without explicit consent of these servers as such resources can contain sensitive information.</li>
</ol>
</blockquote>
<p>You can find more detailed information about the reasons of these decisions in my <a title="Cross-domain XHR, Access-Control, preflight" href="http://engin.bzzzt.biz/2010/01/25/cross-domain-xhr-access-control-preflight/">previous post</a>.</p>
<p>So what this means is;</p>
<ul>
<li>Only if a very new browser with the new specs implement is being used,
<ul>
<li>and target domain explicitly allows the originating domain then XHR can be used for XD communication.</li>
<li>and if target domain does NOT explicitly allows the originating domain, only simple requests such as GET will be send to the target domain, and response will not be readable by the script.</li>
</ul>
</li>
<li>If a browser with new specs implement is NOT being used, then a security exception will be thrown right away.</li>
</ul>
<h3><strong>Conclusion: <span style="color: #ff0000;">FAIL</span></strong><strong>.</strong></h3>
<p>Because a cross browser method with XHR for XD communication does NOT exist.</p>
<h2>2. Script</h2>
<p style="text-align: left;">Script is one of the elements which are not restricted by the same-origin policy (SOP). Script is abused in such a manner that it allows us to do XD communication. Below figure demonstrates how script method works.</p>
<p style="text-align: left;">
<p style="text-align: left;"><a href="http://engin.bzzzt.biz/wp-content/uploads/2010/03/xdscript_web.png"><img class="size-full wp-image-177 aligncenter" title="xdscript_web" src="/assets/xdscript_web.png" alt="Script method workflow" width="430" height="210" /></a></p>
<p>Here's what's going on in the above figure:</p>
<ol>
<li>origin.com tries to load a JS script from remote.com/service.php</li>
<li>as the script from remote.com loads, it immediately calls a message handler in origin.com</li>
<li>hence remote.com passed information to origin.com which is an actual XD communication.</li>
</ol>
<p>Here's what the mysterious $.getScript does roughly;</p>
<ol>
<li>Create a &lt;script&gt; element in the origin.com</li>
<li>Set src (source) property to "http://remote.com/service.php".</li>
<li>Adds the newly created script element to &lt;head&gt; element of the page.</li>
</ol>
<p>Of course, in practice JQuery does a little bit more to ensure performance and browser <a title="JQuery browser compability" href="http://docs.jquery.com/Browser_Compatibility">compatibility</a>.</p>
<h3><strong>Conclusion: <span style="color: #99cc00;">Works </span>but...</strong></h3>
<ul>
<li>Data writing is handled with query parameters in the URL of the HTTP GET request. Such as http://remote.com/service.php?data=value. This comes with the restriction of the URL length. In practice, a 2kb of URL is said to be cross-browser compatible. So data writing is limited to 2kb.</li>
<li>Long-polling is required to get a persistent connection going. i.e. once the server gives the response, you need to re-establish the connection. This wastes resources such as bandwidth.</li>
<li>Error detection is not built-in. Browser does not tell if you if the server broke the ongoing TCP connection (which is the HTTP GET request). So you need to handle errors in your code.</li>
<li>remote.com should be trusted, as it will execute code on your page.</li>
</ul>
<h2>3. IFRAME hack</h2>
<p>This is a hack which is explained quite well in <a title="Facebook Wiki" href="http://wiki.developers.facebook.com/index.php/Cross_Domain_Communication">Facebook wiki</a>.</p>
<p><a href="http://engin.bzzzt.biz/wp-content/uploads/2010/03/Docs_xdcomm.png"><img class="aligncenter size-full wp-image-182" title="IFRAME Hack" src="/assets/Docs_xdcomm.png" alt="" width="825" height="745" /></a>Different from script method, this hack requires a proxy program (xd_receiver.php in the figure above). This has the advantage of you can filter the data coming from remote.com (facebook.com in the figure). But this is also has the disadvantage of adding another layer of maintenance in the chain.</p>
<h3><strong>Conclusion: <span style="color: #99cc00;">Works </span>but...</strong></h3>
<ul>
<li>All the problems with the script methods applies to this method, except the lust one, the remote.com trust issue.</li>
</ul>
<h2>4. IFRAME + form</h2>
<p>This technique enables you to post data to remote.com, without apparent reload of the page (i.e. AJAX-ish).</p>
<p>Here's how:</p>
<ol>
<li>You create a &lt;form&gt; element, set it's .method to "POST" and .action to "http://remote.com/service.php"</li>
<li>Create an &lt;iframe&gt; and insert the &lt;form&gt; element you've just craeted</li>
<li>Call form.submit();</li>
</ol>
<p>From my tests with Chrome and Firefox I've seen that this actually posts the data (I can see it on my server) but cannot read the returned result from the server. Which means you cannot see if the result of POSTing actually did something on the server. You just POST it.</p>
<p>Another deal breaker is the "click" sound Internet Explorer makes each time you call submit(). This practically renders this method useless itself.</p>
<h3><strong>Conclusion: </strong><span style="color: #ff0000;"><strong>FAILS </strong></span><strong>because...</strong></h3>
<ul>
<li>You cannot read the response from the server from Javascript.</li>
<li>Each time you call submit() method, Internet Explorer makes the click noise (which is called "Start Navigation")</li>
</ul>
<h2>5. IFRAME + form + hack</h2>
<p>I haven't tested this technique in theory you should be able to merge the technique 3 and 4 together to form this. To make this happen, http://remote.com/service.php should make a HTTP redirect to http://origin.com/xc_receiver.php?data=response.</p>
<p>Though the "click" sound of Internet Explorer practically renders this solution useless too.</p>
<h3><strong>Conclusion: </strong><span style="color: #ff0000;"><strong>FAILS </strong></span><strong>because...</strong></h3>
<ul>
<li>Each time you call submit() method, Internet Explorer makes the click noise (which is called "Start Navigation")</li>
</ul>
<h2>6. Flash</h2>
<p>This method has so much advantages that I'm very surprised that it is so rarely used. i.e. it is not used for Facebook chat.</p>
<p>In this method you use an invisible Flash object which provides an interface to the Javascript code via ExternalInterface.addCallback, and access to Javascript code via ExternalInterface.call(). It works like a charm and TCP connection capabilities of the Flash is naturally much much more robust than the above hacks. Flash also provides very good error handling.</p>
<p>Plus you can use binary protocols with this, which can reduce bandwidth from 10x to x easily. You can upload any amount of data and receive any amount of data. You can a real TCP connection ready for your command for all times. Spectacular!</p>
<p>As an example a sample Facebook chat packet is 686 bytes including HTTP headers but the actual data is only 179 bytes. Facebook uses long polling, so every packet must be wrapped in a HTTP packet, hence the overhead is quite significant. Also this data is packed in rather verbose JSON format. If it was also a binary format the savings would be more, such as 80 bytes instead of 686 bytes. Rationally speaking though, packing data in binary for WEB might not be very wise and might not just worth the effort. Just getting rid of off HTTP overhead saves %73 bandwidth. On the other hand a hypothetical binary protocol could have save 88%. While that little %15 bandwidth could mean a lot for high scale web sites, it might well not worth the effort since it complicates things and adds other layers to design. Anyways...</p>
<p>Flash is so good that it is hard to find an argument against it. I've tried really hard;</p>
<p><strong>Flash is a plug-in!</strong></p>
<p>Availability of Flash can be questioned. According to <a href="http://www.adobe.com/products/player_census/flashplayer/version_penetration.html">http://www.adobe.com/products/player_census/flashplayer/version_penetration.html</a>, market penetration of Flash 9 is 99%. I think, this makes Flash a even more portable way than above solutions. And according to google-analytics of our site which receives 30k visits (I know not very big), 100% of the users have Flash.</p>
<p><strong>Not available in mobile platforms!</strong></p>
<p>True. Currently Flash support on mobile devices are limited. Though there's this fact that, each mobile device inevitably requires its very own UI design. For instance, Facebook's mobile HTML page dose not offer Chat functionality at all. Though other native applications for iPhone and Windows Mobile offers this service.</p>
<p>That's to say, each mobile device will inevitably has its own UI anyway (which doesn't use Flash). So this argument is not very sound neither.</p>
<p><strong>Flash's TCP connection could be blocked!</strong></p>
<p>Common firewall set ups do not block outgoing TCP connections. And if you use a known port for your remote.com such as 80 or 443, your Firewall most likely can't tell the difference. To tell the difference a statefull Firewall is required, and if a network has those firewalls most likely most of the sites (such as Facebook) are blocked anyway.</p>
<p>Another network problem could be that, all TCP connections are blocked and only HTTP Proxy is allowed, so that your browser is configured to use that HTTP Proxy by default. In this case Flash will fail. Though other methods mentioned above could also fail when a proxy is present. i.e. a long persistent connection which long polls use are not what HTTP Proxies are designed for.</p>
<h3><strong>Conclusion: </strong><span style="color: #99cc00;"><strong>Works</strong></span></h3>
<h1>Finally</h1>
<p>As you might have already noticed my personal bias is towards Flash, though I'm not sure why it isn't wildly deployed as I'd imagine. I have successfully implemented the &lt;script&gt; and Flash methods myself, and I believe Flash is superior. I think only time can tell which is the best solution :)</p>
<p>Cheers.</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Engin AYDOGAN<br />
                Thinker<br />
                e@ea.tl
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/engina</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/jastsayn</a><br />
                <a class="extra" href="90s/">90s</a>
              </p>
            </div>
          </div>
        </div>
    </body>
</html>
