<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Design approaches to web applications revisited</title>
        <meta name="viewport" content="width=device-width">
        <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" type="text/javascript"></script>
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Design approaches to web applications revisited</h2>
<p class="meta">11 Dec 2012</p>

<div class="post">
<h1>Traditional Way</h1>
<p>Traditional web applications consist of several "pages". Each page requires external resources such as CSS, Javascript and image files to be fetched. Every time we load a web page those resources are also loaded with it. So whenever you navigate from one page to another, all these resources are loaded again and most of these resources are static. They are always the same, yet, they are reloaded every time you navigate in the web site.</p>
<p>Implementations and specifications are evolved to remedy these design problems. Each resource was retrieved by a separate connection in HTTP 1.0, it was only since HTTP 1.1, we started to re-use existing connections to retrieve additional resources. Even then, to be a good network citizen, browsers only open limited number of connections to an origin, so additional resources are queued and fetched in serial fashion anyway.</p>
<p>Additionally, we started to use HTTP caching directive headers aggressively to avoid re-fetching of the resources.</p>
<p>Furthermore, we enabled gzip compression to compress textual data in the server before sending it to the browsers which support it.</p>
<p>But no matter what you do, even if you avoid re-fetching resources completely, the browsers reloads them from its cache. This means they are processed again and cause visual imperfection, as you can notice the page is being re-rendered.</p>
<p>Furthermore when we reload the page, it is a challenge to keep the state of all the visual components. This is basically due to HTTP is being an inherently stateless design.</p>
<p>This is, obviously, a severely broken way. Web's needs have changed and this design is clearly far from ideal for today's scenarios.</p>
<h1>A more modern approach</h1>
<p>For the past few years, I've adopted another design approach which today's web giants such as Facebook, Twitter and finally Google too have adopted to some degree.</p>
<p>Even though it has existed before that, a new technique called Ajax emerged around 2005 which is basically just a feature that you can use to send web requests in the background without reloading the web page and get the result back. So, with this technique, you could retrieve new information, such as live stock data, in the background and update some part of the page without reloading it completely.</p>
<p>This was actually a ground braking approach. It remedies most of the flaws of the traditional way of web application development. Yet, it took quite some time for people adopt and really use it. For instance, Google Ajaxified Youtube's comment system just a few years ago. Even though, Facebook used Ajax for many of its tasks for a very long time, Facebook recently Ajaxified most of its interface, such as when you click on a photo, it just pops up a dialog right now instead of sending you to another page -- which was the case about a year ago.</p>
<p>I do believe that ideal web application is just a single static web page which can be served with very high speed, redundant technologies such as CDN servers which have no dynamic page creation ability. After the web application is loaded, it'll communicate with the back-end server via Ajax requests in the background. I've used this technique successfully and the result was amazing, it was the fastest user experience I've ever seen in a web page. I've engineered whole thing to be as fast as possible.</p>
<p>Try it for yourselves, I was playing with a toy project which is now in hiatus status, which is hosted at <a href="http://beta.gettingback.at/">http://beta.gettingback.at/</a>. Go ahead and test the speed for yourselves. Once, it is cached, It takes 600 ms for the whole page to be loaded and rendered completely, from a server which is 2600 km away. Clicking on any link on the page just pops up another dialog to show you the information you are requesting. If you design your application smarter, you can fetch-ahead some of the data user is most likely to click so the experience can get even more faster. The responsiveness and perceived speed is outstanding.</p>
<h1>A single static web application</h1>
<h1>Benefits</h1>
<p>- <strong>Lower requirements.</strong> You can serve the UI file with the dummiest web servers available even with the lowest technology CDN servers.<br />
- <strong>Minimal bandwidth usage.</strong> As all the communication is done over Ajax and all transferred information is strictly data and no repetitive, redundant information (such as the presentation logic -- i.e. html).  This cuts cuts bandwidth costs.<br />
- <strong>Minimal server load, distributed computing.</strong> As presentation logic is completely on the client, server does not need to fiddle with templates and all sort of stuff which has a computational expense. Hence, in a sense, you are distributing computing expenses to the clients.<br />
- <strong>Optimizable</strong>. Single static web page proved to be easier to optimize -- more on that later.</p>
<h1>Problems</h1>
<p>- <strong>Lack of frameworks.</strong> Since this approach is not widely adopted there are lack of frameworks that dictate best practices.<br />
- <strong>Back and forward buttons.</strong> As this approach keeps the user in one single page back and forward buttons' job is rendered useless. Luckily enough, this was the first problem noticed with Ajax and had been worked on for a long time and solutions exist.</p>
<h1>What's the best way to communicate with the API ?</h1>
<p>So, how should we design our API ? We most probably want our API to be accessible by the world as 3rd party developers will use it. This means cross-domain communication. If our API is at http://api.foo.com and another page such as http://static.foo.com tries to access it, it will be a cross domain communication.</p>
<p>What are our options for cross domain communication ?</p>
<p>I've studied the subject in my post <a href="http://ea.tl/2010/03/31/cross-domain-data-push-methods-compared/">Cross-domain data-push methods compared</a> <strong>two years ago</strong>. Back then, using a transparent Flash as cross-domain communication proxy seem like the way to go to me. Mainly because:</p>
<p>- Flash can maintain a single connection and many request-response on it<br />
- Flash has raw TCP connection so you can freely implement a bandwidth efficient protocol.<br />
- Flash was a very ubiquitous technology which was available in %99 of the browsers -- making it the most cross-browser method.</p>
<p>Though it proved to have some<a href="http://ea.tl/2010/04/15/externalinterface-performance-on-different-browsers/"> performance challenges</a>.</p>
<p>Other dominant competing methods was JSONP and XHR.</p>
<p>JSONP is inherently cross-domain compatibly while XHR had cross-domain communication support with the introduction of <a href="http://www.w3.org/TR/access-control/">CORS</a> and IE introduced CORS support in IE8. Back at the time I wrote above comparison article IE6 and IE7 market share was %19,6 according to <a href="http://www.w3schools.com/browsers/browsers_explorer.asp">statistics</a> hence rendering the XHR CORS method not available in at least %19,6 of the market. Now, things has changed and IE6 and IE7 market share dropped to %1.5 as of October 2012.</p>
<p>This makes XHR with CORS compatible with the vast majority of the market, most likely above %95. So, XHR is a serious choice again.</p>
<p>JSONP virtually has 100% browser compatibility.</p>
<p>Furthermore, JSONP and XHR are mobile device friendly unlike Flash. This leaves us two serious competitors for modern times, JSONP and XHR.</p>
<table border="1">
<tbody>
<tr>
<td></td>
<td style="text-align: center;"><strong>JSONP</strong></td>
<td style="text-align: center;"><strong>XHR CORS</strong></td>
</tr>
<tr>
<td><strong>Browser compatibility</strong></td>
<td style="text-align: center;">%100</td>
<td style="text-align: center;">%95 (roughly according to <a href="http://www.w3schools.com/browsers/browsers_stats.asp">statistics</a>)</td>
</tr>
<tr>
<td><strong>Error handling (failed requests)</strong></td>
<td style="text-align: center;">Poor</td>
<td style="text-align: center;">Built-in</td>
</tr>
<tr>
<td><strong>Ability to upload data without 2kb limit</strong></td>
<td style="text-align: center;">NO (As it only supports GET method)</td>
<td style="text-align: center;">YES</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><strong>I believe it is justified to chose XHR technology for cross domain communication today.</strong></p>
<p>YouTube API already has XHR support with this new access control specification. Though, Facebook still uses JSONP internally for most of its communication, probably because it is working just fine.</p>
<h1>Caveats of XHR CORS</h1>
<p>From now on, I'll refer to XHR assuming it has CORS implementation.</p>
<p>Now, there are at least two types of XHR requests defined as I've already wrote about <a href="http://ea.tl/2010/01/25/cross-domain-xhr-access-control-preflight/">here</a>.</p>
<p>- <strong>Simple requests</strong>: These are the requests with HTTP methods GET, POST or HEAD and have no custom HTTP headers in it.<br />
- <strong>Not so simple requests</strong>:  Any request who does not fit into above criteria is not a simple request and requires a preflight request (explained below). So, this renders strictly RESTful APIs which rely on PUT and DELETE methods less robust.</p>
<p><strong>What is a preflight request ?</strong></p>
<p>If browser decides it requires a preflight request, it first sends an HTTP request with method OPTIONS to ask if the server allows you to do cross domain requests to her then the actual request is executed. So a preflight request means doubling your number of requests for a resource. If you keep asking for the same resource (URL part before that #) preflight cache will be used and you'll spare subsequent OPTIONS requests. But if you ask for different resources (foo.php?q=a and foo.php?q=b) then each of these requests will require preflight requests.</p>
<p><strong>So what can be do about preflight requests ?</strong></p>
<p>- We can use a simple requests which does not require preflight requests at all -- that is only GET, POST, HEAD methods with no custom headers.</p>
<p>If that is not an option and we inevitably need preflight requests -- for instance because we need to add custom HTTP headers to our request:</p>
<p>- We can use a single entry point to our api (api.php) and pass all the parameters via POST to keep the URL fixed hence there will only be one preflight request. Basically, we'll just have http://api.foo.com/api.php and send all the parameters to that very same resource with POST parameters hence require only one single preflight request.</p>
<p>Sometimes, the JS libraries we use send custom headers by default. For instance ExtJS, Dojo and Prototype JS libraries were sending custom HTTP headers without consulting the developer, rendering a simple request complex one and hence requiring a preflight request. Maybe some of those libraries have some ways to stop this behavior, I haven't check.</p>
<p>For instance, with ExtJS you can stop it using custom headers with the following  property.</p>
<pre class="prettyprint">Ext.Ajax.useDefaultXhrHeader = false;
Ext.Ajax.request({url: ............... });</pre>
<p>Note that, this API is not documented for normal ExtJS as it is marked as a private API but it is documented in ExtJS Touch API.</p>
<h1>Conclusion for server-side designs</h1>
<p>You have two options</p>
<h5>1) Single entry point API handler</h5>
<p>I believe the most robust way is to have a single entry point and encourage using POST method only. All interaction will be done on your entry point so even if preflight is required, it will be done only once.</p>
<p>HTTP <strong>POST</strong> your parameters, such as <strong>{controller: user, method: search, query: foo}</strong> to <strong>http://foo.com/api.php</strong>. Note, that you are always interacting with the same URL. POST method is chosen over GET because it can reliably send more data than GET method.</p>
<p>This pattern contradicts with most of the server-side you'll find today as they adopt MVC pattern with pretty URLs as their design choice.</p>
<h5>2) Pretty URLs with strictly simple requests</h5>
<p>The frameworks out there which adopted MVC pattern and preferred pretty URLs create many resources. This might have an impact on the performance as they might require separate preflight request for each resource such as <strong>http://api.foo.com/post/5</strong> and <strong>http://api.foo.com/post/8</strong> are both different resources and require separate preflight requests -- unless they are strictly simple requests.</p>
<p>So, if we want to use multiple resource APIs, we should make sure our clients are sending simple requests. Otherwise we'll perform poorly as a preflight will be required for each resource.</p>
<h1>Final thoughts for server-side design</h1>
<p>In many scenarios the only difference between the implementation of two options listed above is an HTTP rewriting module in the web server. As you can rewrite <strong>http://api.foo.com/user/add</strong> into <strong>http://api.foo.com/?c=user&amp;m=add</strong> anyway. Their implementations are pretty much the same but the way they perform in different scenarios are different -- as one of them would require preflight and the other won't.</p>
<p>As for the CORS specification. I couldn't figure out, why the CORS specifications require separate preflight requests per resource. I believe a domain/path wide access-control policy would be more robust.</p>
<p>If particular resources need special restrictions they could still do it, as each HTTP request has an <em>origin</em> header in it, per resource restrictions might be applied too.</p>
<p>I don't know why it hasn't been designed this way.</p>
<h1>Client-side design</h1>
<p>Everything is fine, we pretty much decided how should our API ideally be designed. Now, what ?</p>
<p>With the new web application design, server-side is just for data retrieval, so we need a powerful ways of designing our user experience in the client side.</p>
<p>There are many Javascript libraries out there, such as venerable jQuery but rarely they provide high quality UI components. Windows provides many controls, similarly, other frameworks such as Qt also provides tons of widgets that we can assemble together to build an application but Javascript ecosystem is just catching up.</p>
<p>If you don't need many UI components such as Grids, Panels and layout managers you should definetely go with jQuery, it is a very innovative and intuitive library that would dramatically make your work simpler.</p>
<p>But if you need a more corporate-like professional applications, you want a consisten look among all your UI components and a big collection of components to chose from. In that respect, ExtJS comes into play. They provide a very high quality JS library. Yet, they naturally, have a much more steep learning curve.</p>
<p>&nbsp;</p>
<h1>How to glue client-side and server side</h1>
<p>Most of the time you have to glue them together manually. This is one department we have to work on. I'm speculating ideas about to generate a JS API on the fly by server via Refletion APIs of the server-side languages. In fact, I'm playing with a server side framework idea does generate an API specification automatically, as you add more services to it. Here's a sample output.</p>
<pre class="prettyprint">{
  "Project":{
    "test":{
      "parameters":{
        "name":{
          "optional":false,
          "type":{
            "name":"String"
          }
        },
        "surname":{
          "optional":false,
          "type":{
            "name":"String"
          }
        }
      }
    }
  },
  "Session":{
    "status":{
      "parameters":[

      ]
    },
    "create":{
      "parameters":[

      ]
    }
  },
  "User":{
    "getStatus":{
      "parameters":[

      ]
    }
  }
}</pre>
<p>&nbsp;</p>
<p>In the mean time, ExtJS acted quicker and they propose a solution to this problem with <a href="http://docs.sencha.com/ext-js/4-1/#!/api/Ext.direct.Manager">Ext.Direct</a>. I'll study its design and probably write about it soon.</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Engin AYDOGAN<br />
                Thinker<br />
                e@ea.tl
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/engina</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/jastsayn</a><br />
                <a class="extra" href="90s/">90s</a>
              </p>
            </div>
          </div>
        </div>
    </body>
</html>
