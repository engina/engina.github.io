<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>State of the ORMs - Engin AYDOGAN's Journal</title>
        <meta name="viewport" content="width=device-width">
        <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" type="text/javascript"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js" type="text/javascript"></script>
        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Engin AYDOGAN's Journal</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>State of the ORMs</h2>
<p class="meta">07 Dec 2012</p>

<div class="post">
<p>Today, we build applications which talk to each other over (web) services. In fact, we go one step further and separate our one single application into many components (MVC) that talk to each other. We call this abstraction approach, <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a> (SoC). In the past 10 years, we've seen many frameworks adopted <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model View Controller</a> (MVC) pattern. Remember when <a href="http://en.wikipedia.org/wiki/Qt_(framework)">Qt4</a> was released in 2005 ? Most hyped feature was the MVC pattern.</p>
<p>These principles and patterns makes the code easier to maintain and test. Furthermore, these separations gave us other opportunities. It showed us once you had your model ready, there are a lot of repeated work to be done.</p>
<ol>
<li>Building a <a href="http://en.wikipedia.org/wiki/Data_access_layer">Data Access Layers</a> (DAL) to persist and manipulate the objects programatically.</li>
<li>Building the graphical user interfaces (GUI) to let users manipulate the objects -- and god... validate the input data.</li>
<li>Building an application programming interface (API) to let other programs manipulate the objects -- and again... validate the input data.</li>
</ol>
<p>These tasks have a base no-brainer code to be prepared all the time. Worse, you need to update all these codes when you update your model. If you do not automate this process, you will be reluctant to make any changes to your program because it is such a pain in the ass -- not to mention all the errors you'd make.</p>
<p>So, it is inevitable that programmers all around the world will find ways to generate code for above tasks. The first one of the above tasks is called <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object Relational Mapping</a> (ORM) and there are countless projects available to do that. ORM is basically generating code that does <a href="http://en.wikipedia.org/wiki/CRUD">Create Read Update Delete</a> (CRUD) operations.</p>
<p>Even though most of the ORM projects achieves same goal, they do have different design choices</p>
<h4>ORM Design Choices</h4>
<h6><span style="line-height: 18px;">1. Generation of </span><span style="line-height: 18px;">type safe</span><span style="line-height: 18px;"> strong interfaces</span></h6>
<p>Strong interfaces and <a href="http://en.wikipedia.org/wiki/Type_safety">type safety</a> are inherently available in many platforms like C# and Java and you can't go wrong with them but ORM is often used with dynamic languages which lacks many of these features, so ORM projects must take extra cautions. <a href="http://cakephp.org/">CakePHP</a> is not just an ORM framework but a complete solution which can dramatically speed up development time for many scenarios. Though, I do not agree with some of their design choices. For instance CakePHP's ORM generates Models with weak interfaces.</p>
<pre class="prettyprint">// Instead of doing this
class StrongInterfaceBook
{
    public function getTitle();
    public function setTitle($str);
    public function getAuthor();
    public function setAuthor(Author $author);
}

// CakePHP generates code like this
class WeakInterfaceBook
{
    public function __call($name, $arguments)
    {
         // Figurative code
         $_fieldsToBeUpdate[$name] = $arguments[0];
    }
}

// So, when you call
$c = new WeakInterfaceBook();
// Not the intentional erros in the following line
$c-&gt;setTilte('Foo');
// Your code will execute just fine ignoring the Title field, as it does not exist.

// If you do that with strong interface
$c = new StrongInterfaceBook();
$c-&gt;setTilte('Foo'); // Raises a compile time error.</pre>
<p>Furthermore, generating strong interfaces help your IDE to auto-complete your code, as the interface can actually be indexed.</p>
<p>I, also, believe that generated code should catch your errors as soon as possible and shouldn't allow any silent errors as in the above example. Imagine you've changed your model and renamed a field. Weak interfaces won't catch the errors and where a strong interface will raise an error as soon as it is compiled.</p>
<p>For PHP, <a href="http://www.doctrine-project.org/">Doctrine</a> and <a href="http://propelorm.org/">propel</a> generates strongly typed, strong interfaces.</p>
<p>For .NET environment, sqlmetal, which is the code generation utility of Microsoft, generates strongly typed interfaces with an ground braking API (LINQ) which has been inspired many frameworks such as propel. Once you know the caveats of LINQ, it is the ultimate DAL.</p>
<p>CakePHP is also not designed to regenerate your model code all the time -- as it overwrite generated model code in each execution, so you have to merge your changes from your version controlling system back to regenerated code.</p>
<p>In other frameworks, you usually derive from the generated code</p>
<pre class="prettyprint">public class BookBase
{
    public string Title
    {
         get
         {
              return m_title;
         }
         set
         {
              validateTitle(value);
              m_title = value;
         }
}

public class Book : BookBase
{
    // Add additional functionality here, so code generated overwrites does not affect you
}</pre>
<p>Microsoft's and propel's code generation tools use this design pattern when generating code.</p>
<h6><span style="line-height: 18px;">2. Utilizing data types and model relationships</span></h6>
<p>Models can define some basic things about its fields, such as minimum, maximum values and length which can be easily checked. If the field is of enum type then allowed values are strictly defined so invalid inputs are easy to catch.</p>
<h6><span style="line-height: 18px;">3. Performance</span></h6>
<p>This is least of my concerns, any widely used framework will be well optimized. IMHO, best approach is to generate as much strongly typed code as possible. Even if you rely on runtime introspection, caching will save the performance penalty anyway.</p>
<h4>ORM approaches</h4>
<p>In my humble opinion, models are the core of any design. Once you have defined  your model you can get save yourself the trouble of writing boilerplate code all over.</p>
<h6>1. Code first</h6>
<p>You code your classes, most probably with some extra meta data which is called annotations in Java and attributes in C#. And PHP has a fake annotations which is implemented by extracting meta data from documentation blocks via reflection API.</p>
<p>Some framework such as Doctrine and CakePHP does not allow you to export this model to a easy to read file but they provide extensive introspection API which you can extract all the information from the models.</p>
<p>I, personally, do not like this approach as it does not feel intuitive to me. It is a different way you have to define your model in each platform.</p>
<p>There are many solutions which use this approach such as Java's Hibernate and PHP's Doctrine. Each project claims to support Database First approach too but they do not favor it and it is not well documented.</p>
<h6>2. Model first</h6>
<p>You define your model here and then generate SQL code to generate the schema in your preferred data base, generate DAL code, or even a REST API complete with documentation and test cases.</p>
<p>I think this is a very good way to start to your project but making changes to your model after you get started (which is inevitable) would require you to sync your database schema with the new model. I've used tools which does this before but I'm not familiar with how Model First ORM frameworks hand database syncing yet.</p>
<h6>2. Database first</h6>
<p>You create your database schema and extract your model from there. I find this approach fine, as there are many tools to let you design your database easily and most likely with the aid of graphical tool. It is like designing your model in SQL and then converting the model from there. Also by changing your schema on the database eliminates syncing your database with the model problem.</p>
<h4>Conclusion</h4>
<p>I favor the code first approach the least but as long as they export the model information in a concise manner, I'm fine with with either of the approach.</p>
<p>Once you have extracted  or designed your Model. There are endless possibilities.</p>
<p>1. You can generate DAL</p>
<p>2. You can generate web services to expose your objects</p>
<p>3. You can generate <a href="http://www.sencha.com/products/extjs">ExtJS</a> models so that ExtJS can communicate with your services</p>
<p>4. You can generate ExtJS UIs</p>
<p>And what's better is, once you changed the model, your changes will be propagated in all your frameworks, given you have followed proper design patterns.</p>

</div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'enginsjournal'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

          <div class="footer">
            <div class="contact">
              <p>
                Engin AYDOGAN<br />
                Thinker<br />
                e@ea.tl
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/engina</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/jastsayn</a><br />
                <a class="extra" href="90s/">90s</a>
              </p>
            </div>
          </div>
        </div>
    </body>
    <script type="text/javascript">
    var k = [];
    $(document).ready(function(){
      $(document).keyup(function(e){
        k.push(e.keyCode);

        while(k.length > 3) {
          k.shift();
        }

        if(k.join() == '57,48,83') {
          document.location.href = '/90s/';
        }
      });
    });
    </script>
</html>
