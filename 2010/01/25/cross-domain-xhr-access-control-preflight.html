<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Cross-domain XHR, Access-Control, preflight - Engin AYDOGAN's Journal</title>
        <meta name="viewport" content="width=device-width">
        <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
        <script src="//crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha3.js"></script>
        <script src="//crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js"></script>

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Engin AYDOGAN's Journal</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Cross-domain XHR, Access-Control, preflight</h2>
<p class="meta">25 Jan 2010</p>

<div class="post">
<p>It looks like my <a title="First Dojo impressions" href="http://engin.bzzzt.biz/2010/01/22/first-dojo-impression/">previous post</a> about the browsers sending OPTIONS request instead of GET has nothing to do with Dojo, which got quite obvious as I saw Prototype is also behaving the same way. I've researched about the topic and here's my insights.</p>
<p>It turned out that some new specifications were implemented in IE8, Safari 4, FF 3.5 and Chrome which allows you to do cross-domain XHR. Which means the pure JS implementation I have demonstrated wasn't supposed to work at all unless this new specification was implemented. Here's what the old XHR spec has to say about cross-domain (cross-origin) requests. Taken from <a href="http://www.w3.org/TR/XMLHttpRequest/#the-open-method">http://www.w3.org/TR/XMLHttpRequest/#the-open-method</a></p>
<blockquote style="width: 90%;"><p>If the <a href="http://www.w3.org/TR/XMLHttpRequest/#origin">origin</a> of <var>url</var> is not <a href="http://www.w3.org/TR/XMLHttpRequest/#same-origin">same origin</a> with the <a href="http://www.w3.org/TR/XMLHttpRequest/#xmlhttprequest-origin"><code>XMLHttpRequest</code> origin</a> the user agent <em>should</em> raise a <code><a href="http://www.w3.org/TR/XMLHttpRequest/#security-err">SECURITY_ERR</a></code> exception and terminate these steps.</p></blockquote>
<p>Not allowing cross-domain XHR was and is really a deal breaker and actually it pretty much stops you from implementing SOA (service oriented architectures) flexibly. But for some good reasons.</p>
<p>Here are a few theoretical scenarios:</p>
<ol>
<li>Imagine you are visiting <em>attacker.com</em> which serves a script that requests <em>bank.com/?action=money_transfer&amp;to=attacker&amp;amount=999999. </em>Assuming you have an active session with the bank, if your browser sends this request to bank.com along with the session cookie, attacker would be able to transfer money to himself. This is called <a href="http://en.wikipedia.org/wiki/CSRF">CSRF</a> (Cross-site request forgery)</li>
<li>Imagine you are visiting <em>attacker.com</em> which serves a script that requests <em>10.0.0.50/confidential_intranet_document.html</em> and sends it to himself via script. This means any client in the trusted LAN network might leak information from the LAN to internet.</li>
<li>Imagine you are visiting <em>trusted.com</em> which happens to have a security hole so that the attacker can inject malicious code in its web pages. For instance, imagine you could embed Javascript in the messages in Facebook. When other users see that message and the Javascript code you injected works on their browser, you could read their cookies, hence steal Facebook session. This is called <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> (cross-site scripting).</li>
</ol>
<p>Though there are other transport mechanisms, such as &lt;script&gt; element which is not restricted by this Same Origin Policy. These mechanisms were used instead of the obvious XHR method to achieve cross-domain requests so far. Though these elements are restricted in their own ways, see below for more detail.</p>
<p>There is a new specification being drafted to address these issues,  <a href="http://www.w3.org/TR/access-control/">http://www.w3.org/TR/access-control/</a> which is the reason why OPTIONS request was being sent instead of GET in my previous post. The new spec says that it is OK to send a simple request (which is defined as GET, HEAD and POST) cross-domain as long as there's no custom header in it. If these conditions are <strong>not </strong>met, there should be a preflight request to ensure that the domain we're requesting the document from allows us to fetch it -- much like Flash's policy file.</p>
<p>Note the <strong>custom headers</strong> clause above. That's the exact reason why Prototype and Dojo was causing an OPTIONS request instead of GET, where regular JS was simply sending GET request. Dojo and Prototype adds custom headers to the requests.</p>
<p>So you might ask; cross-domain XHR was not allowed for a good reason, why is it being allowed now ?</p>
<p>Yes, cross-domain XHR is allowed now, but apparently no different than cross-domain requests you can send via img or script elements. Remember that you could always do cross-domain requests with img element too, but img element has two features that makes it not a security problem:</p>
<ol>
<li>img only can send the cookies for the domain it is loaded from. i.e. it is hard to use a remote session since it won't send the target site's cookie.<br />
Consider the first scenario above. If the request does not include a cookie for the bank.com, there'll be no session. It will be a anonymous request. (Of course unless the target site uses session ID as a part of the URL, and the attacker got that SID, which is very unlikely. And if he has the SID he'll hijack your session all together anyway).</li>
<li>You cannot read the contents of an img element, hence you cannot steal sensitive information which you aren't supposed to read.</li>
</ol>
<p>Now, I have demonstrated myself in my previous post that cross-domain XHR worked out fine. My server received the GET request. BUT in the client xhr.responseText was empty and xhr.status was 0 (not 200). It is true that the request was actually made, but you cannot read the contents of the resource. Here's what access-control spec says about this in <a href="http://www.w3.org/TR/access-control/#requirements">http://www.w3.org/TR/access-control/#requirements</a></p>
<blockquote style="width: 90%;">
<ol>
<li>Should not allow loading and exposing of resources from 3<sup>rd</sup> party servers without explicit consent of these servers as such resources can contain sensitive information.</li>
</ol>
</blockquote>
<p>One of the requirements of the spec is not to expose resources without explicit consent. From what I understand, here, explicit consent means Access-Control-Allow-Origin header. If the third party server allows other hosts to read its resources via this header, everything will be fine. So, this means that the new XHR is no security hole bigger than the IMG itself.</p>
<p>In fact, I've tested this. It turns out that when you add this header to your resource, cross-domain XHR starts to work to the fullest. i.e. you can read the content of the requested resource, as in, it is readable in xhr.responseText.</p>
<p>For your information, you can add any headers to your resources with mod_header module of Apache httpd. Just add this directive for whatever directory you want;</p>
<pre class="prettyprint">Header set Access-Control-Allow-Origin "*"</pre>
<p>Keep in mind that, this will expose all of your resources in that directory for anyone to read. So, do this if your resources are public anyway. Or just allow the hosts you want. It could be better to do this in the programming layer, such as PHP or ASP.NET.</p>
<p>So in conclusion, with the new access-control spec, XHR is pretty similar to the Flash's security design. Browser checks if the third party host allows you to read your resources, if so your script is allowed to read it. Note that you can make the request anyway, but reading the resource is not allowed.</p>
<p>This is a nice step forward actually, but since it will take some time that majority of the market is using browsers implement this new spec, web developers are bound to use iframe or script transports for cross-domain request.</p>

</div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'enginsjournal'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

          <div class="footer">
            <div class="contact">
              <p>
                Engin AYDOGAN<br />
                Thinker<br />
                e@ea.tl
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/engina</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/jastsayn</a><br />
              </p>
            </div>
          </div>
        </div>
    </body>
    <script type="text/javascript">
    var k = [];
    $(document).ready(function(){
      $(document).keypress(function(e){
        console.log(e);
        k.push(e.which);

        while(k.length > 64) {
          k.shift();
        }
        if(e.which != 13) return;
        // OMG! OMG! OMG! Is this an easter egg?
        k.pop();
        if(CryptoJS.SHA3(k.join()).toString() == 'd24cbabf2cfe116cd74597b61095a44f40bcc89d7b1acde8158ad23c38b5409a84d37d3c00a74639b4f5df228d2d734a52b93675fd60a5ad56a303c79950e8d3') {
          var p = ''; $(k).each(function(e,b){p += String.fromCharCode(b);});
          document.location.href = CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt('U2FsdGVkX188+NsdA42FiRFwL9yG8aa/GEgHdIO2Cpw=', p));
        }
        k = [];
      });
    });
    </script>
</html>
